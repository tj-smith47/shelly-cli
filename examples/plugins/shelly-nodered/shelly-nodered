#!/usr/bin/env bash
# shelly-nodered - Export Shelly devices to Node-RED flows
#
# A Shelly CLI plugin that generates Node-RED flow JSON files
# for registered Shelly devices.
#
# Dependencies:
#   jq - JSON processing
#
# Environment Variables (provided by Shelly CLI):
#   SHELLY_CONFIG_PATH   - Path to config file
#   SHELLY_DEVICES_JSON  - JSON of registered devices
#   SHELLY_OUTPUT_FORMAT - Current output format (table, json, yaml)
#   SHELLY_NO_COLOR      - Set to 1 if colors disabled

set -euo pipefail

VERSION="0.1.0"
SCRIPT_NAME="shelly-nodered"

# Colors (respects SHELLY_NO_COLOR)
if [[ -z "${SHELLY_NO_COLOR:-}" ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    CYAN='\033[0;36m'
    NC='\033[0m'
else
    RED=''
    GREEN=''
    YELLOW=''
    CYAN=''
    NC=''
fi

# Check dependencies
check_dependencies() {
    if ! command -v jq &>/dev/null; then
        echo -e "${RED}Error:${NC} jq is required for this plugin" >&2
        echo "  Install: apt install jq (Debian) or brew install jq (macOS)" >&2
        return 1
    fi
}

# Generate UUID-like ID for Node-RED nodes
generate_node_id() {
    local prefix="$1"
    echo "${prefix}.$(head -c 8 /dev/urandom | od -An -tx1 | tr -d ' \n' | head -c 8)"
}

# Generate Node-RED flow for a device
generate_device_flow() {
    local device="$1"
    local name="$2"
    local ip="$3"
    local gen="$4"
    local type="$5"
    local x_pos="$6"
    local y_pos="$7"

    local inject_id=$(generate_node_id "inject")
    local http_id=$(generate_node_id "http")
    local switch_id=$(generate_node_id "switch")
    local debug_id=$(generate_node_id "debug")

    # Create RPC URL based on generation
    local status_url toggle_url
    if [[ "$gen" == "1" ]]; then
        status_url="http://$ip/status"
        toggle_url="http://$ip/relay/0?turn=toggle"
    else
        status_url="http://$ip/rpc/Shelly.GetStatus"
        toggle_url="http://$ip/rpc/Switch.Toggle?id=0"
    fi

    cat <<EOF
        {
            "id": "$inject_id",
            "type": "inject",
            "z": "FLOW_ID",
            "name": "$name Status",
            "props": [],
            "repeat": "",
            "crontab": "",
            "once": false,
            "onceDelay": 0.1,
            "topic": "",
            "x": $x_pos,
            "y": $y_pos,
            "wires": [["$http_id"]]
        },
        {
            "id": "$http_id",
            "type": "http request",
            "z": "FLOW_ID",
            "name": "$name API",
            "method": "GET",
            "ret": "obj",
            "paytoqs": "ignore",
            "url": "$status_url",
            "tls": "",
            "persist": false,
            "proxy": "",
            "insecureHTTPParser": false,
            "authType": "",
            "senderr": false,
            "headers": [],
            "x": $((x_pos + 180)),
            "y": $y_pos,
            "wires": [["$debug_id"]]
        },
        {
            "id": "$debug_id",
            "type": "debug",
            "z": "FLOW_ID",
            "name": "$name Output",
            "active": true,
            "tosidebar": true,
            "console": false,
            "tostatus": true,
            "complete": "payload",
            "targetType": "msg",
            "statusVal": "payload",
            "statusType": "auto",
            "x": $((x_pos + 380)),
            "y": $y_pos,
            "wires": []
        }
EOF
}

# Generate complete Node-RED flows file
generate_flows() {
    local output_file="${1:-shelly-flows.json}"
    local devices_json=${SHELLY_DEVICES_JSON:-"{}"}

    echo -e "${CYAN}Generating Node-RED flows...${NC}"

    local flow_id=$(generate_node_id "flow")
    local tab_id=$(generate_node_id "tab")

    # Start JSON array
    local flows="["

    # Add tab (flow container)
    flows+=$(cat <<EOF
    {
        "id": "$tab_id",
        "type": "tab",
        "label": "Shelly Devices",
        "disabled": false,
        "info": "Auto-generated Shelly device controls\\nGenerated by shelly-nodered plugin",
        "env": []
    }
EOF
)

    local count=0
    local y_pos=80

    while IFS= read -r device; do
        local name=$(echo "$devices_json" | jq -r --arg d "$device" '.[$d].name // $d')
        local ip=$(echo "$devices_json" | jq -r --arg d "$device" '.[$d].address // .[$d].ip // .[$d].host // empty')
        local gen=$(echo "$devices_json" | jq -r --arg d "$device" '.[$d].generation // "2"')
        local type=$(echo "$devices_json" | jq -r --arg d "$device" '.[$d].type // "switch"')

        if [[ -z "$ip" ]]; then
            echo -e "${YELLOW}Warning:${NC} Skipping $device - no IP address" >&2
            continue
        fi

        flows+=","
        flows+=$(generate_device_flow "$device" "$name" "$ip" "$gen" "$type" 120 "$y_pos")

        ((count++))
        y_pos=$((y_pos + 100))
    done < <(echo "$devices_json" | jq -r 'keys[]')

    # Replace FLOW_ID placeholder with actual tab ID
    flows=$(echo "$flows" | sed "s/FLOW_ID/$tab_id/g")

    flows+="]"

    # Pretty print and save
    echo "$flows" | jq '.' > "$output_file"

    echo -e "${GREEN}✓${NC} Generated $count device(s) to $output_file"
}

# Generate subflow for reusable Shelly control
generate_subflow() {
    local output_file="${1:-shelly-subflow.json}"

    echo -e "${CYAN}Generating Node-RED subflow...${NC}"

    cat > "$output_file" <<'EOF'
[
    {
        "id": "shelly_control_subflow",
        "type": "subflow",
        "name": "Shelly Control",
        "info": "Control a Shelly device.\n\nInputs:\n- msg.payload.action: 'on', 'off', 'toggle', 'status'\n- msg.payload.ip: Device IP address\n- msg.payload.gen: Device generation (1 or 2)\n\nOutputs:\n- msg.payload: Device response",
        "category": "Shelly",
        "in": [{"x": 50, "y": 30, "wires": [{"id": "switch_action"}]}],
        "out": [{"x": 450, "y": 30, "wires": [{"id": "http_req", "port": 0}]}],
        "env": [
            {"name": "DEVICE_IP", "type": "str", "value": ""},
            {"name": "DEVICE_GEN", "type": "num", "value": "2"}
        ],
        "meta": {"version": "0.1.0", "author": "shelly-nodered", "license": "MIT"},
        "color": "#87CEEB"
    },
    {
        "id": "switch_action",
        "type": "switch",
        "z": "shelly_control_subflow",
        "name": "Action",
        "property": "payload.action",
        "propertyType": "msg",
        "rules": [
            {"t": "eq", "v": "on", "vt": "str"},
            {"t": "eq", "v": "off", "vt": "str"},
            {"t": "eq", "v": "toggle", "vt": "str"},
            {"t": "else"}
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 150,
        "y": 30,
        "wires": [["build_on"], ["build_off"], ["build_toggle"], ["build_status"]]
    },
    {
        "id": "build_on",
        "type": "function",
        "z": "shelly_control_subflow",
        "name": "Build ON URL",
        "func": "const ip = msg.payload.ip || env.get('DEVICE_IP');\nconst gen = msg.payload.gen || env.get('DEVICE_GEN');\nif (gen == 1) {\n    msg.url = `http://${ip}/relay/0?turn=on`;\n} else {\n    msg.url = `http://${ip}/rpc/Switch.Set?id=0&on=true`;\n}\nreturn msg;",
        "outputs": 1,
        "x": 280,
        "y": 10,
        "wires": [["http_req"]]
    },
    {
        "id": "build_off",
        "type": "function",
        "z": "shelly_control_subflow",
        "name": "Build OFF URL",
        "func": "const ip = msg.payload.ip || env.get('DEVICE_IP');\nconst gen = msg.payload.gen || env.get('DEVICE_GEN');\nif (gen == 1) {\n    msg.url = `http://${ip}/relay/0?turn=off`;\n} else {\n    msg.url = `http://${ip}/rpc/Switch.Set?id=0&on=false`;\n}\nreturn msg;",
        "outputs": 1,
        "x": 280,
        "y": 30,
        "wires": [["http_req"]]
    },
    {
        "id": "build_toggle",
        "type": "function",
        "z": "shelly_control_subflow",
        "name": "Build Toggle URL",
        "func": "const ip = msg.payload.ip || env.get('DEVICE_IP');\nconst gen = msg.payload.gen || env.get('DEVICE_GEN');\nif (gen == 1) {\n    msg.url = `http://${ip}/relay/0?turn=toggle`;\n} else {\n    msg.url = `http://${ip}/rpc/Switch.Toggle?id=0`;\n}\nreturn msg;",
        "outputs": 1,
        "x": 280,
        "y": 50,
        "wires": [["http_req"]]
    },
    {
        "id": "build_status",
        "type": "function",
        "z": "shelly_control_subflow",
        "name": "Build Status URL",
        "func": "const ip = msg.payload.ip || env.get('DEVICE_IP');\nconst gen = msg.payload.gen || env.get('DEVICE_GEN');\nif (gen == 1) {\n    msg.url = `http://${ip}/status`;\n} else {\n    msg.url = `http://${ip}/rpc/Shelly.GetStatus`;\n}\nreturn msg;",
        "outputs": 1,
        "x": 280,
        "y": 70,
        "wires": [["http_req"]]
    },
    {
        "id": "http_req",
        "type": "http request",
        "z": "shelly_control_subflow",
        "name": "Shelly API",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "x": 400,
        "y": 30,
        "wires": [[]]
    }
]
EOF

    echo -e "${GREEN}✓${NC} Generated subflow to $output_file"
}

# Generate dashboard nodes (requires node-red-dashboard)
generate_dashboard() {
    local output_file="${1:-shelly-dashboard.json}"
    local devices_json=${SHELLY_DEVICES_JSON:-"{}"}

    echo -e "${CYAN}Generating Node-RED dashboard...${NC}"

    local flows="["
    local tab_id=$(generate_node_id "tab")
    local group_id=$(generate_node_id "group")
    local ui_tab_id=$(generate_node_id "ui_tab")
    local ui_group_id=$(generate_node_id "ui_group")

    # UI Tab
    flows+=$(cat <<EOF
    {
        "id": "$ui_tab_id",
        "type": "ui_tab",
        "name": "Shelly",
        "icon": "dashboard",
        "order": 1,
        "disabled": false,
        "hidden": false
    },
    {
        "id": "$ui_group_id",
        "type": "ui_group",
        "name": "Devices",
        "tab": "$ui_tab_id",
        "order": 1,
        "disp": true,
        "width": "6",
        "collapse": false
    },
    {
        "id": "$tab_id",
        "type": "tab",
        "label": "Shelly Dashboard",
        "disabled": false,
        "info": "Dashboard controls for Shelly devices"
    }
EOF
)

    local count=0
    local y_pos=80

    while IFS= read -r device; do
        local name=$(echo "$devices_json" | jq -r --arg d "$device" '.[$d].name // $d')
        local ip=$(echo "$devices_json" | jq -r --arg d "$device" '.[$d].address // .[$d].ip // .[$d].host // empty')
        local gen=$(echo "$devices_json" | jq -r --arg d "$device" '.[$d].generation // "2"')

        if [[ -z "$ip" ]]; then
            continue
        fi

        local switch_id=$(generate_node_id "ui_switch")
        local func_id=$(generate_node_id "function")
        local http_id=$(generate_node_id "http")

        local toggle_url
        if [[ "$gen" == "1" ]]; then
            toggle_url="http://$ip/relay/0?turn=toggle"
        else
            toggle_url="http://$ip/rpc/Switch.Toggle?id=0"
        fi

        flows+=","
        flows+=$(cat <<EOF
    {
        "id": "$switch_id",
        "type": "ui_switch",
        "z": "$tab_id",
        "name": "$name",
        "label": "$name",
        "tooltip": "",
        "group": "$ui_group_id",
        "order": $((count + 1)),
        "width": 0,
        "height": 0,
        "passthru": false,
        "decouple": "true",
        "topic": "topic",
        "topicType": "msg",
        "style": "",
        "onvalue": "true",
        "onvalueType": "bool",
        "onicon": "",
        "oncolor": "",
        "offvalue": "false",
        "offvalueType": "bool",
        "officon": "",
        "offcolor": "",
        "animate": true,
        "x": 120,
        "y": $y_pos,
        "wires": [["$http_id"]]
    },
    {
        "id": "$http_id",
        "type": "http request",
        "z": "$tab_id",
        "name": "$name Toggle",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "$toggle_url",
        "tls": "",
        "persist": false,
        "proxy": "",
        "x": 300,
        "y": $y_pos,
        "wires": [[]]
    }
EOF
)

        ((count++))
        y_pos=$((y_pos + 60))
    done < <(echo "$devices_json" | jq -r 'keys[]')

    flows+="]"
    echo "$flows" | jq '.' > "$output_file"

    echo -e "${GREEN}✓${NC} Generated dashboard with $count device(s) to $output_file"
    echo -e "${YELLOW}Note:${NC} Requires node-red-dashboard to be installed"
}

# List devices
list_devices() {
    local devices_json=${SHELLY_DEVICES_JSON:-"{}"}

    echo -e "${CYAN}Devices available for export:${NC}"
    echo ""

    local count=0
    while IFS= read -r device; do
        local name=$(echo "$devices_json" | jq -r --arg d "$device" '.[$d].name // $d')
        local ip=$(echo "$devices_json" | jq -r --arg d "$device" '.[$d].address // .[$d].ip // .[$d].host // "unknown"')
        local gen=$(echo "$devices_json" | jq -r --arg d "$device" '.[$d].generation // "2"')
        local type=$(echo "$devices_json" | jq -r --arg d "$device" '.[$d].type // "switch"')

        printf "  %-20s %-15s Gen%s %-10s\n" "$name" "$ip" "$gen" "$type"
        ((count++))
    done < <(echo "$devices_json" | jq -r 'keys[]')

    echo ""
    echo "Total: $count device(s)"
}

# Show help
show_help() {
    cat <<EOF
${CYAN}shelly-nodered${NC} - Export Shelly devices to Node-RED flows

${YELLOW}Usage:${NC}
    shelly nodered <command> [options]

${YELLOW}Commands:${NC}
    flows [file]      Generate Node-RED flows file (default: shelly-flows.json)
    subflow [file]    Generate reusable Shelly control subflow
    dashboard [file]  Generate dashboard flows (requires node-red-dashboard)
    list              List devices that would be exported
    help              Show this help
    version           Show version

${YELLOW}Options:${NC}
    -h, --help        Show help
    -v, --version     Show version

${YELLOW}Examples:${NC}
    # Generate basic flows
    shelly nodered flows

    # Generate dashboard
    shelly nodered dashboard

    # Generate reusable subflow
    shelly nodered subflow

    # List available devices
    shelly nodered list

${YELLOW}Import into Node-RED:${NC}
    1. Open Node-RED editor
    2. Click menu (☰) → Import
    3. Select file or paste JSON
    4. Click Import

${YELLOW}Requirements:${NC}
    - Node-RED 2.x or 3.x
    - For dashboard: node-red-dashboard package
    - jq (for JSON processing)
EOF
}

# Show version
show_version() {
    echo "$SCRIPT_NAME version $VERSION"
}

# Main entry point
main() {
    check_dependencies || exit 1

    local cmd="${1:-help}"

    case "$cmd" in
    -h | --help | help)
        show_help
        ;;
    -v | --version | version)
        show_version
        ;;
    flows)
        shift
        generate_flows "${1:-shelly-flows.json}"
        ;;
    subflow)
        shift
        generate_subflow "${1:-shelly-subflow.json}"
        ;;
    dashboard)
        shift
        generate_dashboard "${1:-shelly-dashboard.json}"
        ;;
    list)
        list_devices
        ;;
    *)
        echo -e "${RED}Error:${NC} Unknown command: $cmd" >&2
        echo "Run 'shelly nodered help' for usage" >&2
        exit 1
        ;;
    esac
}

main "$@"
